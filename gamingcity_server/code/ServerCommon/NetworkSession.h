#pragma once

#include "perinclude.h"
#include "GameLog.h"

// 消息头
#pragma pack(1)

/**********************************************************************************************//**
 * \struct	MsgHeader
 *
 * \brief	消息头.
 **************************************************************************************************/

struct MsgHeader
{
	unsigned short							len;		// 消息总长度
	unsigned short							id;			// 消息id
};

/**********************************************************************************************//**
 * \struct	GateMsgHeader
 *
 * \brief	跟gate server转发消息的消息头.
 **************************************************************************************************/

struct GateMsgHeader : public MsgHeader
{
	int										guid;		// 数据库中唯一
};

#pragma pack()


#define MSG_SEND_BUFFER_SIZE (16 * 1024)
#define MSG_RECV_BUFFER_SIZE (16 * 1024)
#define MSG_WRITE_BUFFER_SIZE (48 * 1024)
#define MSG_READ_BUFFER_SIZE (48 * 1024)
#define MSG_ONE_BUFFER_SIZE (8 * 1024)

/**********************************************************************************************//**
 * \class	NetworkSession
 *
 * \brief	A network session.
 **************************************************************************************************/

class NetworkSession : public std::enable_shared_from_this < NetworkSession >
{
public:

	/**********************************************************************************************//**
	 * \brief	Constructor.
	 *
	 * \param [in,out]	ioservice	The ioservice.
	 **************************************************************************************************/

	NetworkSession(boost::asio::io_service& ioservice);

	/**********************************************************************************************//**
	 * \brief	Constructor.
	 *
	 * \param [in,out]	sock	The sock.
	 **************************************************************************************************/

	NetworkSession(boost::asio::ip::tcp::socket& sock);

	/**********************************************************************************************//**
	 * \brief	Destructor.
	 **************************************************************************************************/

	virtual ~NetworkSession();

	/**********************************************************************************************//**
	 * \brief	Gets the socket.
	 *
	 * \return	A reference to a boost::asio::ip::tcp::socket.
	 **************************************************************************************************/

	boost::asio::ip::tcp::socket& socket()
	{
		return socket_;
	}

	/**********************************************************************************************//**
	 * \brief	得到id，等于socket().native().
	 *
	 * \return	The identifier.
	 **************************************************************************************************/

	int get_id() { return id_; }

	/**********************************************************************************************//**
	 * \brief	设置id.
	 *
	 * \param	id	The identifier.
	 **************************************************************************************************/

	void set_id(int id) { id_ = id; }

	/**********************************************************************************************//**
	 * \brief	accept成功后调用.
	 **************************************************************************************************/

	void start();

	/**********************************************************************************************//**
	 * \brief	连接.
	 *
	 * \param	ip  	The IP.
	 * \param	port	The port.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	virtual bool connect(const char* ip, unsigned short port);

	/**********************************************************************************************//**
	 * \brief	每一帧调用.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	virtual bool tick();

	// 发送

	/**********************************************************************************************//**
	 * \brief	发送消息，长度为msg->len.
	 *
	 * \param [in]	msg	If non-null, the message.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	bool send(MsgHeader* msg);

	/**********************************************************************************************//**
	 * \brief	发送消息.
	 *
	 * \param [in]	data		If non-null, the data.
	 * \param	len				The length.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	bool send(void* data, size_t len);

	/**********************************************************************************************//**
	 * \brief	发送消息，打包成字符串的pb.
	 *
	 * \param	id	The identifier.
	 * \param	pb	The pb.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	bool send_spb(unsigned short id, const std::string& pb);

	/**********************************************************************************************//**
	 * \brief	对gate发送消息，打包成字符串的pb.
	 *
	 * \param	guid	Unique identifier.
	 * \param	id  	The identifier.
	 * \param	pb  	The pb.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	bool send_c_spb(int guid, unsigned short id, const std::string& pb);

	/**********************************************************************************************//**
	 * \brief	发送消息，protobuf格式.
	 *
	 * \tparam	T	Generic type parameter.
	 * \param [in]	pb	If non-null, the pb.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	template<typename T> bool send_pb(T* pb)
	{
		try
		{
			std::string str = pb->SerializeAsString();
			return send_spb(T::ID, str);
		}
		catch (const std::exception& e)
		{
			LOG_ERR("pb error:%s", e.what());
		}
		return false;
	}

	/**********************************************************************************************//**
	 * \brief	GateServer将client消息转发到其他服务器.
	 *
	 * \param	guid	  	数据库中唯一.
	 * \param [in]	header	If non-null, the header.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	bool send_cx(int guid, MsgHeader* header);

	/**********************************************************************************************//**
	 * \brief	GateServer将其他服务器的消息转发给client.
	 *
	 * \param [in]	header	If non-null, the header.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	bool send_xc(GateMsgHeader* header);

	/**********************************************************************************************//**
	 * \brief	其他服务器向GateServer发送消息.
	 *
	 * \tparam	T	Generic type parameter.
	 * \param	guid	数据库中唯一.
	 * \param [in]	pb	If non-null, the pb.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	template<typename T> bool send_xc_pb(int guid, T* pb)
	{
		try
		{
			std::string str = pb->SerializeAsString();
			return send_c_spb(guid, T::ID, str);
		}
		catch (const std::exception& e)
		{
			LOG_ERR("pb error:%s", e.what());
		}
		return false;
	}

	/**********************************************************************************************//**
	 * \brief	调用该还是，才会真正的发送消息.
	 **************************************************************************************************/

	void post();

	/**********************************************************************************************//**
	 * \brief	对收到的消息组包.
	 **************************************************************************************************/

	virtual bool dispatch();

	/**********************************************************************************************//**
	 * \brief	关闭该socket连接.
	 **************************************************************************************************/

	void close();

	/**********************************************************************************************//**
	 * \brief	派生类处理收到的消息.
	 *
	 * \param [in]	header	If non-null, the header.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	virtual bool on_dispatch(MsgHeader* header);

	/**********************************************************************************************//**
	 * \brief	派生类处理接受回调.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	virtual bool on_accept() { return true; };

	/**********************************************************************************************//**
	 * \brief	派生类处理连接回调.
	 *
	 * \return	true if it succeeds, false if it fails.
	 **************************************************************************************************/

	virtual bool on_connect() { return true; };

	/**********************************************************************************************//**
	 * \brief	派生类处理连接失败回调.
	 **************************************************************************************************/

	virtual void on_connect_failed() {};

	/**********************************************************************************************//**
	 * \brief	派生类处理关闭socket后回调.
	 **************************************************************************************************/

	virtual void on_closed() {}

	/**********************************************************************************************//**
	 * \brief	Gets local IP port.
	 *
	 * \param [out]	ip	The IP.
	 *
	 * \return	The local IP port.
	 **************************************************************************************************/

	unsigned short get_local_ip_port(std::string& ip);

	/**********************************************************************************************//**
	 * \brief	Gets remote IP port.
	 *
	 * \param [out]	ip	The IP.
	 *
	 * \return	The remote IP port.
	 **************************************************************************************************/

	unsigned short get_remote_ip_port(std::string& ip);

	/**********************************************************************************************//**
	 * \brief	得到服务器id.
	 *
	 * \return	The server identifier.
	 **************************************************************************************************/

	virtual int get_server_id() { return 0; }
	
	/**********************************************************************************************//**
	 * \brief	开始读.
	 *
	 * \return	The server identifier.
	 **************************************************************************************************/

	void start_read();
protected:

	/**********************************************************************************************//**
	 * \brief	Handles the read.
	 *
	 * \param	error			 	The error.
	 * \param	bytes_transferred	The bytes transferred.
	 **************************************************************************************************/

	void handle_read(const boost::system::error_code& error, size_t bytes_transferred);

	/**********************************************************************************************//**
	 * \brief	Executes the write operation.
	 **************************************************************************************************/

	void do_write();

	/**********************************************************************************************//**
	 * \brief	Handles the write.
	 *
	 * \param	error			 	The error.
	 * \param	bytes_transferred	The bytes transferred.
	 **************************************************************************************************/

	void handle_write(const boost::system::error_code& error, size_t bytes_transferred);

	/**********************************************************************************************//**
	 * \brief	关闭socket.
	 **************************************************************************************************/

    virtual void do_close();

	/**********************************************************************************************//**
	 * \brief	重新初始化一些数据.
	 **************************************************************************************************/

	void reset();

protected:
	boost::asio::ip::tcp::socket			socket_;
	int										id_;

	bool									sending_;

public:
	/**********************************************************************************************//**
	 * \class	MsgBuffer
	 *
	 * \brief	消息缓存.
	 *
	 * \tparam	N	Type of the n.
	 **************************************************************************************************/

	template<size_t N>
	class MsgBuffer
	{
	public:

		/**********************************************************************************************//**
		 * \brief	Default constructor.
		 **************************************************************************************************/

		MsgBuffer()
			: size_(0)
		{

		}

		/**********************************************************************************************//**
		 * \brief	得到buf数据.
		 *
		 * \return	null if it fails, else a pointer to a char.
		 **************************************************************************************************/

		char* data() { return buf_; }

		/**********************************************************************************************//**
		 * \brief	得到buf使用多少.
		 *
		 * \return	A size_t.
		 **************************************************************************************************/

		size_t size() { return size_; }

		/**********************************************************************************************//**
		 * \brief	得到buf剩余多少没有使用.
		 *
		 * \return	A size_t.
		 **************************************************************************************************/

		size_t remain() { return N - size_; }

		/**********************************************************************************************//**
		 * \brief	buf是否为空.
		 *
		 * \return	true if it succeeds, false if it fails.
		 **************************************************************************************************/

		bool empty() { return 0 == size_; }

		/**********************************************************************************************//**
		 * \brief	设置增加使用了多少buf.
		 *
		 * \param	pos	The position to add.
		 *
		 * \return	true if it succeeds, false if it fails.
		 **************************************************************************************************/

		bool add(size_t pos)
		{
			if (pos > N - size_)
				return false;
			size_ += pos;
			return true;
		}

		/**********************************************************************************************//**
		 * \brief	写入一个缓冲数据.
		 *
		 * \param [in]	data		If non-null, the data.
		 * \param	len				The length.
		 *
		 * \return	true if it succeeds, false if it fails.
		 **************************************************************************************************/

		bool push(void* data, size_t len)
		{
			if (len > N - size_)
				return false;
			memcpy(buf_ + size_, data, len);
			size_ += len;
			return true;
		}

		/**********************************************************************************************//**
		 * \brief	写入一个消息.
		 *
		 * \param [in]		msg	If non-null, the message to push.
		 *
		 * \return	true if it succeeds, false if it fails.
		 **************************************************************************************************/

		bool push(MsgHeader* msg)
		{
			return push(msg, msg->len);
		}

		/**********************************************************************************************//**
		 * \brief	清理buf.
		 **************************************************************************************************/

		void clear() { size_ = 0; }

		/**********************************************************************************************//**
		 * \brief	移除pos前面的buf数据.
		 *
		 * \param	pos	The position.
		 **************************************************************************************************/

		void move(size_t pos)
		{
			if (pos < size_)
			{
				memmove(buf_, buf_ + pos, size_ - pos);
				size_ -= pos;
			}
			else
			{
				size_ = 0;
			}
		}

	private:
		char								buf_[N];
		size_t								size_;
	};
	typedef MsgBuffer<MSG_SEND_BUFFER_SIZE>	MsgSendBuffer;
	typedef MsgBuffer<MSG_RECV_BUFFER_SIZE>	MsgRecvBuffer;
	typedef MsgBuffer<MSG_WRITE_BUFFER_SIZE> MsgWirteBuffer;
	typedef MsgBuffer<MSG_READ_BUFFER_SIZE>	MsgReadBuffer;

protected:

	/** \brief	发送缓冲. */
	MsgSendBuffer							send_buf_;
	/** \brief	收取缓冲. */
	MsgRecvBuffer							recv_buf_;
	/** \brief	逻辑线程写入. */
	MsgWirteBuffer							write_buf_;
	/** \brief	逻辑线程处理消息. */
	MsgReadBuffer							read_buf_;

	// 二级缓存
	std::deque<MsgWirteBuffer*>				buf2_write_;
	std::deque<MsgReadBuffer*>				buf2_read_;


	std::recursive_mutex					mutex_;

	// 超时
	time_t									last_msg_time_;
};
